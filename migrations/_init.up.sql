-- init.up.sql
-- Postgres baseline for Medusa signage platform

-- Extensions
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS citext;

-- Helper: updated_at trigger ===
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Users
CREATE TABLE IF NOT EXISTS users (
  id               BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email            CITEXT NOT NULL UNIQUE,
  hashed_password  TEXT   NOT NULL,
  name             TEXT,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TRIGGER trg_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Screens
CREATE TABLE IF NOT EXISTS screens (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  device_id   TEXT NOT NULL UNIQUE,
  name        TEXT NOT NULL,
  location    TEXT,
  paired      BOOLEAN NOT NULL DEFAULT FALSE,
  created_by  BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  last_seen_at TIMESTAMPTZ,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_screens_created_by ON screens(created_by);

CREATE TRIGGER trg_screens_updated_at
BEFORE UPDATE ON screens
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Screen assignments (many-to-many screen<->user)
CREATE TABLE IF NOT EXISTS screen_assignments (
  screen_id BIGINT NOT NULL REFERENCES screens(id) ON DELETE CASCADE,
  user_id   BIGINT NOT NULL REFERENCES users(id)   ON DELETE CASCADE,
  PRIMARY KEY (screen_id, user_id)
);
CREATE INDEX IF NOT EXISTS idx_screen_assignments_user   ON screen_assignments(user_id);
CREATE INDEX IF NOT EXISTS idx_screen_assignments_screen ON screen_assignments(screen_id);

-- Content
CREATE TABLE IF NOT EXISTS content (
  id                 BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name               TEXT NOT NULL,
  type               TEXT NOT NULL,
  url                TEXT NOT NULL,
  resolution_width   INT,
  resolution_height  INT,
  created_by         BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT content_type_chk CHECK (type IN ('image','video','html','integration')),
  CONSTRAINT content_resolution_chk CHECK (
    (resolution_width  IS NULL OR resolution_width  > 0) AND
    (resolution_height IS NULL OR resolution_height > 0)
  )
);

CREATE INDEX IF NOT EXISTS idx_content_created_by ON content(created_by);

CREATE TRIGGER trg_content_updated_at
BEFORE UPDATE ON content
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Playlists
CREATE TABLE IF NOT EXISTS playlists (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        TEXT NOT NULL,
  description TEXT,
  created_by  BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_playlists_created_by ON playlists(created_by);

CREATE TRIGGER trg_playlists_updated_at
BEFORE UPDATE ON playlists
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Items in a playlist
CREATE TABLE IF NOT EXISTS playlist_items (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  playlist_id  BIGINT NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,
  content_id   BIGINT NOT NULL REFERENCES content(id)   ON DELETE RESTRICT,
  position     INT    NOT NULL,
  duration     INT    NOT NULL,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT duration_pos_chk CHECK (duration > 0 AND position >= 1),
  CONSTRAINT uniq_order_per_playlist UNIQUE (playlist_id, position) DEFERRABLE INITIALLY DEFERRED
);

CREATE INDEX IF NOT EXISTS idx_playlist_items_playlist_pos     ON playlist_items(playlist_id, position);
CREATE INDEX IF NOT EXISTS idx_playlist_items_playlist_content ON playlist_items(playlist_id, content_id);

CREATE TRIGGER trg_playlist_items_updated_at
BEFORE UPDATE ON playlist_items
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Assign a playlist to a screen (only one active at a time per screen)
CREATE TABLE IF NOT EXISTS screen_playlists (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  screen_id    BIGINT NOT NULL REFERENCES screens(id)   ON DELETE CASCADE,
  playlist_id  BIGINT NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,
  active       BOOLEAN NOT NULL DEFAULT TRUE,
  assigned_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_screen_playlists_screen ON screen_playlists(screen_id);
CREATE UNIQUE INDEX IF NOT EXISTS uq_active_playlist_per_screen
  ON screen_playlists(screen_id) WHERE active;

-- Scheduling (no overlaps per screen when enabled)
-- playlist-based scheduling and a time range
CREATE TABLE IF NOT EXISTS schedules (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  screen_id    BIGINT NOT NULL REFERENCES screens(id)   ON DELETE CASCADE,
  playlist_id  BIGINT NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,
  -- Inclusive lower bound, exclusive upper bound recommended (e.g., ['2025-08-01', '2025-08-02'))
  time_window       TSTZRANGE NOT NULL,
  priority     INT NOT NULL DEFAULT 0,
  enabled      BOOLEAN NOT NULL DEFAULT TRUE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT valid_window CHECK (lower(time_window) IS NOT NULL AND upper(time_window) IS NOT NULL AND lower(time_window) < upper(time_window))
);

-- Prevent overlapping windows for the same screen when enabled
ALTER TABLE schedules
  ADD CONSTRAINT no_overlap
  EXCLUDE USING gist (
    screen_id WITH =,
    time_window    WITH &&
  )
  WHERE (enabled);

CREATE INDEX IF NOT EXISTS idx_schedules_screen ON schedules(screen_id);
CREATE INDEX IF NOT EXISTS idx_schedules_enabled ON schedules(enabled);

