CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS citext;

-- updated_at trigger
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- @USERS
CREATE TABLE IF NOT EXISTS users (
  id               BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email            CITEXT NOT NULL UNIQUE,
  hashed_password  TEXT   NOT NULL,
  name             TEXT,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now()
);

DROP TRIGGER IF EXISTS trg_users_updated_at ON users;
CREATE TRIGGER trg_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- @SCREENS
CREATE TABLE IF NOT EXISTS screens (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  device_id TEXT NOT NULL UNIQUE,
  client_information TEXT,
  client_width INT,
  client_height INT,
  name TEXT NOT NULL,
  location TEXT,
  paired BOOLEAN NOT NULL DEFAULT false,
  created_by BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_screens_created_by ON screens(created_by);

DROP TRIGGER IF EXISTS trg_screens_updated_at ON screens;
CREATE TRIGGER trg_screens_updated_at
BEFORE UPDATE ON screens
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- screen assignments many to many 
CREATE TABLE IF NOT EXISTS screen_assignments (
  screen_id BIGINT NOT NULL REFERENCES screens(id) ON DELETE CASCADE,
  user_id   BIGINT NOT NULL REFERENCES users(id)   ON DELETE CASCADE,
  PRIMARY KEY (screen_id, user_id)
);
CREATE INDEX IF NOT EXISTS idx_screen_assignments_user   ON screen_assignments(user_id);
CREATE INDEX IF NOT EXISTS idx_screen_assignments_screen ON screen_assignments(screen_id);

-- @CONTENT
CREATE TABLE IF NOT EXISTS content (
  id                 BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name               TEXT NOT NULL,
  type               TEXT NOT NULL,
  url                TEXT NOT NULL,
  resolution_width   INT,
  resolution_height  INT,
  created_by         BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT content_type_chk CHECK (type IN ('image','video','html','integration')),
  CONSTRAINT content_resolution_chk CHECK (
    (resolution_width  IS NULL OR resolution_width  > 0) AND
    (resolution_height IS NULL OR resolution_height > 0)
  )
);

CREATE INDEX IF NOT EXISTS idx_content_created_by ON content(created_by);

DROP TRIGGER IF EXISTS trg_content_updated_at ON content;
CREATE TRIGGER trg_content_updated_at
BEFORE UPDATE ON content
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- @PLAYLISTS
CREATE TABLE IF NOT EXISTS playlists (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        TEXT NOT NULL,
  description TEXT,
  created_by  BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_playlists_created_by ON playlists(created_by);

DROP TRIGGER IF EXISTS trg_playlists_updated_at ON playlists;
CREATE TRIGGER trg_playlists_updated_at
BEFORE UPDATE ON playlists
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- @PLAYLIST_ITEMS
CREATE TABLE IF NOT EXISTS playlist_items (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  playlist_id  BIGINT NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,
  content_id   BIGINT NOT NULL REFERENCES content(id)   ON DELETE RESTRICT,
  position     INT    NOT NULL,
  duration     INT    NOT NULL,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT duration_pos_chk CHECK (duration > 0 AND position >= 1),
  CONSTRAINT uniq_order_per_playlist UNIQUE (playlist_id, position) DEFERRABLE INITIALLY DEFERRED
);

CREATE INDEX IF NOT EXISTS idx_playlist_items_playlist_pos     ON playlist_items(playlist_id, position);
CREATE INDEX IF NOT EXISTS idx_playlist_items_playlist_content ON playlist_items(playlist_id, content_id);

DROP TRIGGER IF EXISTS trg_playlist_items_updated_at ON playlist_items;
CREATE TRIGGER trg_playlist_items_updated_at
BEFORE UPDATE ON playlist_items
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- screen <==> playlist
CREATE TABLE IF NOT EXISTS screen_playlists (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  screen_id    BIGINT NOT NULL REFERENCES screens(id)   ON DELETE CASCADE,
  playlist_id  BIGINT NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,
  active       BOOLEAN NOT NULL DEFAULT TRUE,
  assigned_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_screen_playlists_screen ON screen_playlists(screen_id);
CREATE UNIQUE INDEX IF NOT EXISTS uq_active_playlist_per_screen
  ON screen_playlists(screen_id) WHERE active;

-- recurrence enum
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'recurrence_kind') THEN
    CREATE TYPE recurrence_kind AS ENUM ('none','daily','weekly','monthly');
  END IF;
END$$;

-- @SCHEDULES
CREATE TABLE IF NOT EXISTS schedules (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name       TEXT NOT NULL,
  created_by BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_schedules_created_by ON schedules(created_by);

DROP TRIGGER IF EXISTS trg_schedules_updated_at ON schedules;
CREATE TRIGGER trg_schedules_updated_at
BEFORE UPDATE ON schedules
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- many-to-many: schedule <-> screen (0..N screens per schedule; screens may have 0 schedules)
CREATE TABLE IF NOT EXISTS schedule_screens (
  schedule_id BIGINT NOT NULL REFERENCES schedules(id) ON DELETE CASCADE,
  screen_id   BIGINT NOT NULL REFERENCES screens(id)  ON DELETE CASCADE,
  PRIMARY KEY (schedule_id, screen_id)
);
CREATE INDEX IF NOT EXISTS idx_schedule_screens_screen ON schedule_screens(screen_id);

-- @WINDOWS: time windows that assign a playlist (recurring or one-shot)
CREATE TABLE IF NOT EXISTS schedule_windows (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  schedule_id  BIGINT NOT NULL REFERENCES schedules(id)  ON DELETE CASCADE,
  playlist_id  BIGINT NOT NULL REFERENCES playlists(id)  ON DELETE CASCADE,
  time_window  TSTZRANGE NOT NULL,           -- [start, end)
  recurrence   recurrence_kind NOT NULL DEFAULT 'none',
  recur_until  TIMESTAMPTZ,                  -- required when recurrence <> 'none'
  priority     INT NOT NULL DEFAULT 0,
  enabled      BOOLEAN NOT NULL DEFAULT TRUE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT valid_window CHECK (
    lower(time_window) IS NOT NULL AND upper(time_window) IS NOT NULL AND lower(time_window) < upper(time_window)
  ),
  CONSTRAINT recur_until_required CHECK (
    (recurrence = 'none' AND recur_until IS NULL) OR
    (recurrence <> 'none' AND recur_until IS NOT NULL AND recur_until > lower(time_window))
  )
);

CREATE INDEX IF NOT EXISTS idx_schedule_windows_schedule ON schedule_windows(schedule_id);
CREATE INDEX IF NOT EXISTS idx_schedule_windows_enabled  ON schedule_windows(enabled);

DROP TRIGGER IF EXISTS trg_schedule_windows_updated_at ON schedule_windows;
CREATE TRIGGER trg_schedule_windows_updated_at
BEFORE UPDATE ON schedule_windows
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Exceptions: delete a single occurrence from a recurring series
CREATE TABLE IF NOT EXISTS schedule_window_exceptions (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  window_id   BIGINT NOT NULL REFERENCES schedule_windows(id) ON DELETE CASCADE,
  occur_start TIMESTAMPTZ NOT NULL,
  UNIQUE (window_id, occur_start)
);

-- Expand occurrences for a given window within [from, to)
CREATE OR REPLACE FUNCTION schedule_window_occurrences(
  p_window_id BIGINT,
  p_from      TIMESTAMPTZ,
  p_to        TIMESTAMPTZ
) RETURNS TABLE(occur_start TIMESTAMPTZ, occur_end TIMESTAMPTZ) AS $$
DECLARE
  w           schedule_windows;
  base_start  TIMESTAMPTZ;
  base_end    TIMESTAMPTZ;
  step        INTERVAL;
  cur_start   TIMESTAMPTZ;
  cur_end     TIMESTAMPTZ;
BEGIN
  SELECT * INTO w FROM schedule_windows WHERE id = p_window_id AND enabled = true;
  IF NOT FOUND THEN RETURN; END IF;

  base_start := lower(w.time_window);
  base_end   := upper(w.time_window);

  IF w.recurrence = 'none' THEN
    IF base_end > p_from AND base_start < p_to THEN
      IF NOT EXISTS (SELECT 1 FROM schedule_window_exceptions e WHERE e.window_id = w.id AND e.occur_start = base_start) THEN
        occur_start := base_start; occur_end := base_end; RETURN NEXT;
      END IF;
    END IF;
    RETURN;
  END IF;

  step := CASE w.recurrence
    WHEN 'daily'   THEN INTERVAL '1 day'
    WHEN 'weekly'  THEN INTERVAL '1 week'
    WHEN 'monthly' THEN INTERVAL '1 month'
  END;

  cur_start := base_start;
  cur_end   := base_end;

  -- fast-forward to the first potential overlap with [p_from, p_to)
  WHILE cur_end < p_from LOOP
    cur_start := cur_start + step; cur_end := cur_end + step;
    IF cur_start > w.recur_until THEN RETURN; END IF;
  END LOOP;

  WHILE cur_start < p_to AND cur_start <= w.recur_until LOOP
    IF cur_end > p_from THEN
      IF NOT EXISTS (SELECT 1 FROM schedule_window_exceptions e WHERE e.window_id = w.id AND e.occur_start = cur_start) THEN
        occur_start := cur_start; occur_end := cur_end; RETURN NEXT;
      END IF;
    END IF;
    cur_start := cur_start + step; cur_end := cur_end + step;
  END LOOP;
END;
$$ LANGUAGE plpgsql STABLE;

-- Overlap checker within a schedule (recurrence-aware)
CREATE OR REPLACE FUNCTION schedule_has_overlap(
  p_schedule_id BIGINT,
  p_playlist_id BIGINT,
  p_time_window TSTZRANGE,
  p_recurrence  recurrence_kind,
  p_recur_until TIMESTAMPTZ
) RETURNS TEXT AS $$
DECLARE
  candidate_id BIGINT;
  existing_id  BIGINT;
  msg TEXT;
BEGIN
  INSERT INTO schedule_windows (schedule_id, playlist_id, time_window, recurrence, recur_until, enabled)
  VALUES (p_schedule_id, p_playlist_id, p_time_window, p_recurrence, p_recur_until, true)
  RETURNING id INTO candidate_id;

  FOR existing_id IN
    SELECT id FROM schedule_windows
     WHERE schedule_id = p_schedule_id
       AND enabled = true
       AND id <> candidate_id
  LOOP
    WITH bounds AS (
      SELECT
        LEAST(lower((SELECT time_window FROM schedule_windows WHERE id = candidate_id)),
              lower((SELECT time_window FROM schedule_windows WHERE id = existing_id))) AS from_ts,
        GREATEST(
          COALESCE((SELECT recur_until FROM schedule_windows WHERE id = candidate_id), upper((SELECT time_window FROM schedule_windows WHERE id = candidate_id))),
          COALESCE((SELECT recur_until FROM schedule_windows WHERE id = existing_id),   upper((SELECT time_window FROM schedule_windows WHERE id = existing_id)))
        ) AS to_ts
    ),
    cand AS (
      SELECT * FROM bounds b, LATERAL schedule_window_occurrences(candidate_id, b.from_ts - INTERVAL '1 month', b.to_ts + INTERVAL '1 month')
    ),
    exist AS (
      SELECT * FROM bounds b, LATERAL schedule_window_occurrences(existing_id,  b.from_ts - INTERVAL '1 month', b.to_ts + INTERVAL '1 month')
    )
    SELECT 'overlaps with window ' || existing_id
      INTO msg
      FROM cand c
      JOIN exist e ON tstzrange(c.occur_start, c.occur_end, '[)') && tstzrange(e.occur_start, e.occur_end, '[)')
      LIMIT 1;

    IF msg IS NOT NULL THEN
      DELETE FROM schedule_windows WHERE id = candidate_id;
      RETURN msg;
    END IF;
  END LOOP;

  DELETE FROM schedule_windows WHERE id = candidate_id;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- @ SCREEN_GROUPS
CREATE TABLE IF NOT EXISTS screen_groups (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        TEXT NOT NULL,
  description TEXT,
  created_by  BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_group_name_per_user UNIQUE (created_by, name)
);

CREATE INDEX IF NOT EXISTS idx_screen_groups_created_by ON screen_groups(created_by);

DROP TRIGGER IF EXISTS trg_screen_groups_updated_at ON screen_groups;
CREATE TRIGGER trg_screen_groups_updated_at
BEFORE UPDATE ON screen_groups
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- many-to-many: screens <-> screen_groups
CREATE TABLE IF NOT EXISTS screen_group_members (
  group_id  BIGINT NOT NULL REFERENCES screen_groups(id) ON DELETE CASCADE,
  screen_id BIGINT NOT NULL REFERENCES screens(id)       ON DELETE CASCADE,
  PRIMARY KEY (group_id, screen_id)
);

CREATE INDEX IF NOT EXISTS idx_sgm_group  ON screen_group_members(group_id);
CREATE INDEX IF NOT EXISTS idx_sgm_screen ON screen_group_members(screen_id);

